{"version":3,"file":"numeric-quantity.umd.production.min.js","sources":["../src/index.ts"],"sourcesContent":["enum VulgarFraction {\n  '¼' = '1/4',\n  '½' = '1/2',\n  '¾' = '3/4',\n  '⅐' = '1/7',\n  '⅑' = '1/9',\n  '⅒' = '1/10',\n  '⅓' = '1/3',\n  '⅔' = '2/3',\n  '⅕' = '1/5',\n  '⅖' = '2/5',\n  '⅗' = '3/5',\n  '⅘' = '4/5',\n  '⅙' = '1/6',\n  '⅚' = '5/6',\n  '⅛' = '1/8',\n  '⅜' = '3/8',\n  '⅝' = '5/8',\n  '⅞' = '7/8',\n}\n\n/**\n * Converts a string to a number.  The string can include mixed numbers\n * or vulgar fractions.\n */\nfunction numericQuantity(qty: string) {\n  const badResult = NaN;\n  let finalResult = badResult;\n\n  // Resolve any unicode vulgar fractions\n  const vulgarFractionsRegex = /(¼|½|¾|⅐|⅑|⅒|⅓|⅔|⅕|⅖|⅗|⅘|⅙|⅚|⅛|⅜|⅝|⅞)/;\n\n  const sQty = `${qty}`\n    .replace(\n      vulgarFractionsRegex,\n      (_m, vf: keyof typeof VulgarFraction) => ` ${VulgarFraction[vf]}`\n    )\n    .trim();\n\n  /**\n   *                    Regex captures\n   *\n   *  +=====+====================+========================+\n   *  |  #  |    Description     |        Example         |\n   *  +=====+====================+========================+\n   *  |  0  |  entire string     |  \"2 2/3\" from \"2 2/3\"  |\n   *  +-----+--------------------+------------------------+\n   *  |  1  |  the dash          |  \"-\" from \"-2 2/3\"     |\n   *  +-----+--------------------+------------------------+\n   *  |  2  |  the whole number  |  \"2\" from \"2 2/3\"      |\n   *  |     |  - OR -            |                        |\n   *  |     |  the numerator     |  \"2\" from \"2/3\"        |\n   *  +-----+--------------------+------------------------+\n   *  |  3  |  entire fraction   |  \"2/3\" from \"2 2/3\"    |\n   *  |     |  - OR -            |                        |\n   *  |     |  decimal portion   |  \".66\" from \"2.66\"     |\n   *  |     |  - OR -            |                        |\n   *  |     |  denominator       |  \"/3\" from \"2/3\"       |\n   *  +=====+====================+========================+\n   *\n   *  re.exec(\"1\")       // [ \"1\",     \"1\", null,   null ]\n   *  re.exec(\"1.23\")    // [ \"1.23\",  \"1\", \".23\",  null ]\n   *  re.exec(\"1 2/3\")   // [ \"1 2/3\", \"1\", \" 2/3\", \" 2\" ]\n   *  re.exec(\"2/3\")     // [ \"2/3\",   \"2\", \"/3\",   null ]\n   *  re.exec(\"2 / 3\")   // [ \"2 / 3\", \"2\", \"/ 3\",  null ]\n   */\n  const re = /^(-)?\\s*(\\d*)(\\.\\d+|(\\s+\\d*\\s*)?\\s*\\/\\s*\\d+)?$/;\n\n  const ar = re.exec(sQty);\n\n  // If the regex fails, give up\n  if (!ar) {\n    return badResult;\n  }\n\n  // Store the capture groups so we don't have to access the array\n  // elements over and over\n  const [, dash, numberGroup1, numberGroup2] = ar;\n\n  // The regex can pass and still capture nothing in the relevant groups,\n  // which means it failed for our purposes\n  if (!numberGroup1 && !numberGroup2) {\n    return badResult;\n  }\n\n  // Numerify capture group 1\n  if (!numberGroup1 && numberGroup2 && numberGroup2.search(/^\\./) !== -1) {\n    finalResult = 0;\n  } else {\n    finalResult = parseInt(numberGroup1);\n  }\n\n  if (isNaN(finalResult)) {\n    return badResult;\n  }\n\n  // If capture group 2 is null, then we're dealing with an integer\n  // and there is nothing left to process\n  if (!numberGroup2) {\n    return finalResult * (dash === '-' ? -1 : 1);\n  }\n\n  if (numberGroup2.search(/^\\./) !== -1) {\n    // If first char is \".\" it's a decimal so just trim to 3 decimal places\n    const numerator = parseFloat(numberGroup2);\n    finalResult += Math.round(numerator * 1000) / 1000;\n  } else if (numberGroup2.search(/^\\s*\\//) !== -1) {\n    // If the first non-space char is \"/\" it's a pure fraction (e.g. \"1/2\")\n    const numerator = parseInt(numberGroup1);\n    const denominator = parseInt(numberGroup2.replace('/', ''));\n    finalResult = Math.round((numerator * 1000) / denominator) / 1000;\n  } else {\n    // Otherwise it's a mixed fraction (e.g. \"1 2/3\")\n    const fractionArray = numberGroup2.split('/');\n    const [numerator, denominator] = fractionArray.map(v => parseInt(v));\n    finalResult += Math.round((numerator * 1000) / denominator) / 1000;\n  }\n\n  return finalResult * (dash === '-' ? -1 : 1);\n}\n\nexport default numericQuantity;\n"],"names":["VulgarFraction","qty","finalResult","NaN","sQty","replace","_m","vf","trim","ar","exec","dash","numberGroup1","numberGroup2","search","parseInt","isNaN","numerator","parseFloat","Math","round","denominator","split","map","v"],"mappings":"sMAAA,IAAKA,SAAL,SAAKA,GACHA,aACAA,aACAA,aACAA,aACAA,aACAA,cACAA,aACAA,aACAA,aACAA,aACAA,aACAA,aACAA,aACAA,aACAA,aACAA,aACAA,aACAA,aAlBF,CAAKA,IAAAA,OAyBL,SAAyBC,OAEnBC,EADcC,IAMZC,MAAUH,GACbI,QAH0B,yCAKzB,SAACC,EAAIC,aAAwCP,EAAeO,MAE7DC,OA+BGC,EAFK,iDAEGC,KAAKN,OAGdK,SA7CaN,QAmDTQ,EAAoCF,KAA9BG,EAA8BH,KAAhBI,EAAgBJ,SAIxCG,IAAiBC,SAvDJV,OA6DhBD,GADGU,GAAgBC,IAAgD,IAAhCA,EAAaC,OAAO,OACzC,EAEAC,SAASH,GAGrBI,MAAMd,UAlEQC,QAwEbU,SACIX,GAAwB,MAATS,GAAgB,EAAI,OAGR,IAAhCE,EAAaC,OAAO,OAAe,KAE/BG,EAAYC,WAAWL,GAC7BX,GAAeiB,KAAKC,MAAkB,IAAZH,GAAoB,SACzC,IAAuC,IAAnCJ,EAAaC,OAAO,UAAkB,KAEzCG,EAAYF,SAASH,GACrBS,EAAcN,SAASF,EAAaR,QAAQ,IAAK,KACvDH,EAAciB,KAAKC,MAAmB,IAAZH,EAAoBI,GAAe,QACxD,OAEiBR,EAAaS,MAAM,KACMC,KAAI,SAAAC,UAAKT,SAASS,MACjEtB,GAAeiB,KAAKC,MAAmB,eAAuB,WAGzDlB,GAAwB,MAATS,GAAgB,EAAI"}