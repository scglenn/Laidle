System.register('numericQuantity', [], function (exports) {
  'use strict';
  return {
    execute: function () {

      var VulgarFraction;

      (function (VulgarFraction) {
        VulgarFraction["\xBC"] = "1/4";
        VulgarFraction["\xBD"] = "1/2";
        VulgarFraction["\xBE"] = "3/4";
        VulgarFraction["\u2150"] = "1/7";
        VulgarFraction["\u2151"] = "1/9";
        VulgarFraction["\u2152"] = "1/10";
        VulgarFraction["\u2153"] = "1/3";
        VulgarFraction["\u2154"] = "2/3";
        VulgarFraction["\u2155"] = "1/5";
        VulgarFraction["\u2156"] = "2/5";
        VulgarFraction["\u2157"] = "3/5";
        VulgarFraction["\u2158"] = "4/5";
        VulgarFraction["\u2159"] = "1/6";
        VulgarFraction["\u215A"] = "5/6";
        VulgarFraction["\u215B"] = "1/8";
        VulgarFraction["\u215C"] = "3/8";
        VulgarFraction["\u215D"] = "5/8";
        VulgarFraction["\u215E"] = "7/8";
      })(VulgarFraction || (VulgarFraction = {}));
      /**
       * Converts a string to a number.  The string can include mixed numbers
       * or vulgar fractions.
       */


      function numericQuantity(qty) {
        var badResult = NaN;
        var finalResult = badResult; // Resolve any unicode vulgar fractions

        var vulgarFractionsRegex = /(¼|½|¾|⅐|⅑|⅒|⅓|⅔|⅕|⅖|⅗|⅘|⅙|⅚|⅛|⅜|⅝|⅞)/;
        var sQty = ("" + qty).replace(vulgarFractionsRegex, function (_m, vf) {
          return " " + VulgarFraction[vf];
        }).trim();
        /**
         *                    Regex captures
         *
         *  +=====+====================+========================+
         *  |  #  |    Description     |        Example         |
         *  +=====+====================+========================+
         *  |  0  |  entire string     |  "2 2/3" from "2 2/3"  |
         *  +-----+--------------------+------------------------+
         *  |  1  |  the dash          |  "-" from "-2 2/3"     |
         *  +-----+--------------------+------------------------+
         *  |  2  |  the whole number  |  "2" from "2 2/3"      |
         *  |     |  - OR -            |                        |
         *  |     |  the numerator     |  "2" from "2/3"        |
         *  +-----+--------------------+------------------------+
         *  |  3  |  entire fraction   |  "2/3" from "2 2/3"    |
         *  |     |  - OR -            |                        |
         *  |     |  decimal portion   |  ".66" from "2.66"     |
         *  |     |  - OR -            |                        |
         *  |     |  denominator       |  "/3" from "2/3"       |
         *  +=====+====================+========================+
         *
         *  re.exec("1")       // [ "1",     "1", null,   null ]
         *  re.exec("1.23")    // [ "1.23",  "1", ".23",  null ]
         *  re.exec("1 2/3")   // [ "1 2/3", "1", " 2/3", " 2" ]
         *  re.exec("2/3")     // [ "2/3",   "2", "/3",   null ]
         *  re.exec("2 / 3")   // [ "2 / 3", "2", "/ 3",  null ]
         */

        var re = /^(-)?\s*(\d*)(\.\d+|(\s+\d*\s*)?\s*\/\s*\d+)?$/;
        var ar = re.exec(sQty); // If the regex fails, give up

        if (!ar) {
          return badResult;
        } // Store the capture groups so we don't have to access the array
        // elements over and over


        var dash = ar[1],
            numberGroup1 = ar[2],
            numberGroup2 = ar[3]; // The regex can pass and still capture nothing in the relevant groups,
        // which means it failed for our purposes

        if (!numberGroup1 && !numberGroup2) {
          return badResult;
        } // Numerify capture group 1


        if (!numberGroup1 && numberGroup2 && numberGroup2.search(/^\./) !== -1) {
          finalResult = 0;
        } else {
          finalResult = parseInt(numberGroup1);
        }

        if (isNaN(finalResult)) {
          return badResult;
        } // If capture group 2 is null, then we're dealing with an integer
        // and there is nothing left to process


        if (!numberGroup2) {
          return finalResult * (dash === '-' ? -1 : 1);
        }

        if (numberGroup2.search(/^\./) !== -1) {
          // If first char is "." it's a decimal so just trim to 3 decimal places
          var numerator = parseFloat(numberGroup2);
          finalResult += Math.round(numerator * 1000) / 1000;
        } else if (numberGroup2.search(/^\s*\//) !== -1) {
          // If the first non-space char is "/" it's a pure fraction (e.g. "1/2")
          var _numerator = parseInt(numberGroup1);

          var denominator = parseInt(numberGroup2.replace('/', ''));
          finalResult = Math.round(_numerator * 1000 / denominator) / 1000;
        } else {
          // Otherwise it's a mixed fraction (e.g. "1 2/3")
          var fractionArray = numberGroup2.split('/');

          var _fractionArray$map = fractionArray.map(function (v) {
            return parseInt(v);
          }),
              _numerator2 = _fractionArray$map[0],
              _denominator = _fractionArray$map[1];

          finalResult += Math.round(_numerator2 * 1000 / _denominator) / 1000;
        }

        return finalResult * (dash === '-' ? -1 : 1);
      }
      exports('default', numericQuantity);

    }
  };
});
//# sourceMappingURL=numeric-quantity.system.development.js.map
